{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { readFile, writeFile } from 'fs/promises';\nimport {\n  determinePath,\n  determineFallback,\n  yarnFetchVersion,\n  npmFetchVersion,\n} from './utilities';\nimport type { NodePlopAPI, CustomActionConfig } from 'node-plop';\n\nexport interface UpdateDependenciesActionConfig\n  extends CustomActionConfig<string> {\n  destination?: string;\n  devDependencies?: string[];\n  peerDependencies?: string[];\n  dependencies?: string[];\n  pkgManager?: 'yarn' | 'npm';\n  fallbackVersion?: string;\n}\n\nexport default (plop: NodePlopAPI) => {\n  plop.setDefaultInclude({ actionTypes: true });\n  plop.setActionType(\n    'updateDependencies',\n    async (\n      data: Record<string, any>,\n      config: UpdateDependenciesActionConfig,\n      plop: NodePlopAPI,\n    ): Promise<string> => {\n      const {\n        devDependencies = [],\n        peerDependencies = [],\n        dependencies = [],\n        pkgManager = 'yarn',\n      } = config;\n\n      const deps: Array<string> = [\n        ...devDependencies,\n        ...peerDependencies,\n        ...dependencies,\n      ].map((pkgName) => plop.renderString(pkgName, data));\n\n      if (!deps.length) {\n        return Promise.resolve(\n          'No dependencies provided; please provide at least one dependency in the config object.',\n        );\n      }\n\n      if (!['yarn', 'npm'].includes(pkgManager)) {\n        return Promise.reject(\n          new Error(`${pkgManager} is an unsupported package manager.`),\n        );\n      }\n\n      const fetchVersion =\n        pkgManager === 'yarn' ? yarnFetchVersion : npmFetchVersion;\n      const destination = determinePath(\n        config.destination,\n        data,\n        plop.renderString,\n      );\n      const fallbackVersion = determineFallback(\n        config.fallbackVersion,\n        data,\n        plop.renderString,\n      );\n      const destinationJSON = readFile(destination, 'utf8');\n      const versions = deps.reduce((acc, pkgName) => {\n        if (acc.has(pkgName)) return acc;\n\n        const result = fetchVersion(pkgName);\n        if (result) {\n          acc.set(pkgName, `^${result}`);\n          return acc;\n        }\n\n        if (fallbackVersion) {\n          console.warn(\n            `Unable to determine version for ${pkgName}, using fallback '${fallbackVersion}'.`,\n          );\n          acc.set(pkgName, fallbackVersion);\n          return acc;\n        }\n\n        console.warn(\n          `Skipping ${pkgName} as no fallback version was provided.`,\n        );\n        return acc;\n      }, new Map<string, string>());\n\n      if (versions.size === 0) {\n        return Promise.resolve('No versions could be determined.');\n      }\n\n      const originalJSON = await destinationJSON.then(JSON.parse).catch(() => {\n        return Promise.reject(\n          new Error(`Unable to read package.json at ${destination}.`),\n        );\n      });\n\n      const newJSON = {\n        ...originalJSON,\n        peerDependencies: {\n          ...originalJSON.peerDependencies,\n          ...peerDependencies.map((pkgName) => ({\n            // why? Peer dependencies should point to a major version, not a specific version.\n            [pkgName]: versions\n              .get(pkgName)!\n              .replace(/\\^([0-9]+)\\.([0-9]+)\\.([0-9]+)$/, '^$1.0.0'),\n          })),\n        },\n        dependencies: {\n          ...originalJSON.dependencies,\n          ...dependencies.map((pkgName) => ({\n            [pkgName]: versions.get(pkgName),\n          })),\n        },\n        devDependencies: {\n          ...originalJSON.devDependencies,\n          ...devDependencies.map((pkgName) => ({\n            [pkgName]: versions.get(pkgName),\n          })),\n        },\n      };\n\n      await writeFile(destination, JSON.stringify(newJSON, null, 2)).catch(\n        () => {\n          return Promise.reject(\n            new Error(`Unable to write package.json at ${destination}.`),\n          );\n        },\n      );\n\n      return Promise.resolve(\n        'Successfully applied local package versions to new component.',\n      );\n    },\n  );\n};\n"]}